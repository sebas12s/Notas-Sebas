
git checkout -t origin/<nombre_rama>: Si existe una rama remota de nombre “nombre_rama”, al ejecutar este comando se crea una rama local con el nombre “nombre_rama” para hacer un seguimiento de la rama remota con el mismo nombre.


git remote prune origin: Actualiza tu repositorio remoto en caso que algún otro desarrollador haya eliminado alguna rama remota.

git revert <hash_commit>: Revierte el commit realizado, identificado por el “hash_commit”.

para borrar una rama en el ropositorio remoto se hace de la siguiente manera
git push origin --delete master     asi seria un ejemplo

para unir una rama con el master se hace el marge pero si tiene que hacer en el master o si no el master o la rama principal se cambia 
git merge "el nombre de la rama que quermos unir"         esto nos une la ultima version de la rama y la de master y nos crea una nueva version 
git branch          esto te muestra las ramas 
recordar que marge es como un commit entonces tiene que llevar un mensaje
git merge se puede hacer en cualquier rama para traer las ultimas versiones del trabajo

si te sale conflicto solo lo arreglas o decides con cual quedarte y despues ya haces el commit y ya quedan los cambios

para salir del editor de codigo de git le da uno esc despues :x! y preciona enter 
hay unos conflictos entre master y main le cambiaron el nombre a main


trabajando con mas persona 
cree un nuevo usuario entonces clone el repositorio donde lo queria copiar al copiarlo no me pidio contrasena por que es un repositorio publicoo 
al intentar subir con push nos pide el usuario y la contrasena pero nos tirara error si no agregamos ese usuario en el repositorio remoto
para agregarlo tenemos que ir a los settings del repositorio en collaborators ahi puedo agregar a otros colaboradores
y ya en su github le aparece la invitacion
a la rama main solo se envia lo que este seguro para trabajar solo eso
los archivos binarios no se tienen que enviar al repositorio en este caso una imagen eso se trabaja por aparte 
al trabajar con binarios se pueden tardar por no se que cosa xd


normalmente la rama main no se puede tocar por que esa sera la version que se subira al servidor o esa es la version final a produccion
para poder trabajar sin tener que tocar el main y poder hacer pruebas y todo eso a ese tipo de servidores se le conoce servidores de staging o de desarrollo
esta branch justo esta antes que master pero ese servidor se le llama servidor de prubas
entonces nosotros no lo enviamos al main lo enviamos al servidor de pruba pero no lo unimos con marge hacemos un pull request que es un estado intermedio antes de enviar el merge
el pull request lo que hace es que otros puedan ver los cambios que ejecutastes y si les gusta hacen el merge
pull request no es de git es de github por que github es el que me permite trabajar con otros git solo controla las versiones de mi trabajo
tambien esta en bitbucket pero se llama push request
y los que hacen todo esto son los lideres de equipo o un perfil muy especial que se les llama DevOps



tag         
son como cuando un juego tiene versiones como 1.18.1 1.18.20 y asi
git tag -a v0.1     el nombre puede ser el que quieras  pero es normal ponerle ese nombre       el nombre va despues de la -a
git tag -a v0.1 -m "" "el hash o el id de la rama pasada"      se le agrega un mensaje tambien      y ya ultimo el id de esa versio 
git tag         si solo ponemos asi podemos ver los tags que tenemos
git show-ref --tags         pero asi muestra donde esta ese tag 
pero el que me muestra ese id me muestra otro diferente al que puse al comienzo
los tags son utiles en github o en sitios abiertos para que los que entren puedan ver que version es y asi
o pueden servir como un cometario para saber donde me quede o algo asi
entonces enviamos o hacemos un push     me tira error cuando lo corro por ubuntu asi que mejor hacerlo en git bash
despues del pull ponemos el siguiente codigo
git push origin --tags      esto dice que vamos a enpujarle nuestros tags
git tag -d "el nombre del tag"      asi se borra un tag 
aunque lo borre en git no se borro en github 
git push origin :refs/tags/dormido      esta es una forma de borrar los tags en ese repositorio donde no se borro



rebase - mala practica es como agarrar una rama y pegarla a tu rama maestra y hacer que nunca se creo
es como si nunca hubiera existido 
em el ejemplo en una rama hicimos experimentos y queremos traer todo eso a la rama main 
dentro de la rama de experimentos ejecutamos
git rebase "la rama main"
primero se le hace rebase a la rama que vamos a eliminar y despues a la rama principal
como el primer rebase se lo hacemos a main esos commits aparecen primero despues aparecen los commits del segundo que le hagamos rebase
primero a la rama que cambia y despues rebase a la rama principal
git checkout -      cambia a la rama anterior en la que estabas
git branch -D "rama"        esto lo eliminado

stashed 
es como guardar unos cambios en alguna parte y volver al ultimo commit es como que esos cambios nunca hubieran pasado pero estan ahi guardados
hice unos cambios pero no les quiero dar commit y necesito regresar una commit anterior entonces le doy 
git stash       esto me regresa al ultimo commit 
git stash list      esto nos muestra el stash echo      el stach como que guarda esos cambios en algun lugar
git stash pop       esto vuelve a lo que teniamos en el stash
git stash branch "nombre de la rama"        y esto envia el stash a otra rama o la crea si no existe la rama
git stash drop          con esto eliminamos el stash


git clean
git clean solo sirve para archivos que estan pendientes a darles add
nos sirve para borrar archivos que sirven en este ejemplo hice unas copias del los archivos
git clean --dry-run         este comando nos sirve para que nos muestre que archivos nos borrara sin borrarlos
git clean -f        y ya este nos borra esos archivos       pero solo archivos no carpetas      tambien ignora todo lo que esta en gitignore    
git clean -q        nos muestra los errores que tuvo la ejecucion pero no los archivos que fueron borrados 
git clean -x        borra las copias incluso las que estan en gitignore
git clean -X        borra archivos que fueron ignorados por git
git clean -f -d         tambien borra directorios


git cherry-pick     
esto nos ayuda a traernos un commit de cualquier version a la rama que queramos sin tener que hacer el merge 
git cherry-pick "el id del commit"              esto se hace desde la rama que queremos ingresarlo  y ya nos trae el commit 
ya despues se puede hacer el merge  
git merge "la rama que queremos traer"          pero nos dara conflicto ya que antes habiamos traido el commit
ya solo resolvemos el conflicto en este caso solo le di aceptar ambos commits
despues de resolver el conflicto debemos de hacer el merge es como darle nombre al otro commit ya con los cambios hechos


git reflog      
esto nos ayuda por si hicimos algo muyy malo entonces queremos volver 
git reflog      nos muestra todo los cambios y lo que eliminamos y asi
ahi copiamos el head donde todo era correcto 
git reset "el head que copiamos"        esto como que nos trae todos los o lo que borramos en este caso pero solo aparece en rojo cuando le damos git status
es como si solo le hubieramos borrado pero no le hubieramos dado ni el add ni el commit 
entonces para traernoslo bien bien hacemos el
git reset --hard "el id del commit"         y ya con esto traemos bien todo
con esto volvemos y no aparece nada pero si ejecutamos el git reflog ahi se guardo los erroes


cuando envias commits y te faltaba algo mas 
se hace el add no de una vez el commit -am      entonces si nos falto el cambio y ya habiamos hecho el commit solo lo cambiamos y le damos 
git add .
git commi --amend           esto lo que hace es que todos los cambios que hice los pega al commit anterior 
despues ya solo nos pide si quermos cambiar el mensaje y ya esta hecho


para buscar alguna palabra en algo usamos
git grep "la palabra"       esto nos muestra donde aparece esa palabra
git grep -n "la palabra"        nos aparece en que linea 
git grep -c "la palabra"        esto nos muestra la cantidad de veces en la que aparece
git log -S "la palabra"         esto si va entre comillas       y esto busca en todos los commits la palabra



alias muy buenos
git shortlog            esto nos muestra como un log por persona los commit que han hecho cada uno de los miembros del equipo
git shortlog -sn        esto solo nos muestra cuantos han hecho la cantidad
git shortlog -sn --all          esto incluso los borrados
git shortlog -sn --all --no-merges          con esto le decimos que no nos incluya los merges       asi solo miramos los commits
para crear el alias se hace de la siguiente manera
git config --global alias."el nombre del alias" "el pedazo del comando"     este si va entre comillas
git config --global alias.stats "shortlog -sn --all --no-merges"        este es el alias que creamos

git blame -c "el nombre del archivo que queremos ver"       esto nos ayuda para ver que y quien hizo cada cosa
git blame "nombre del archivo o direccion" -L33,50 -c           los numeros son las lineas de cual a cual queremos ver los cambios y la c es para ordenar un poco


git resotore .      vuelve a todo sin los cambios 



